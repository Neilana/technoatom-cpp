# Задание 2
1.  - [x] Реализуйте класс Массив с внешним хранением данных (аналог std::vector). Конструктор копирования и оператор присваивания пока не определяйте. Во все методы добавьте распечатки названия функций и дампы, чтобы видеть, какие методы и когда вызывались, и в каком состоянии был объект. Дополните класс Массив деструктором и конструктором с единственным параметром (explicit пока не ставьте).

2.  - [x] Сделайте тестовую программу для демонстрации неявного вызова конструктора с единственным параметром. Добавьте к его описанию explicit и убедитесь, что неявные вызовы стали синтаксическими ошибками.

3.  - [x] Добавьте к тестовой программе функцию, принимающую объект класса Массив по значению (с копированием), и совершающую с ним какие-то операции. Конструктор копирования и оператор присваивания пока не определяйте. С помощью распечаток и дампов пронаблюдайте вызов двух деструкторов для двух разных объектов класса Массив (оригинала и копии; они должны различаться по значению this) и несоответствие количества распечаток от конструкторов распечаткам от деструкторов, т.к. конструктор копирования Вы пока не определили, компилятор сгенерирует его сам и распечатки в нем, соответственно, не будет. Пронаблюдайте двойное освобождение памяти, в которой хранятся данные массива, для этого можно написать свою функцию для удаления массива, снабдив ее распечаткой с указанием адреса освобождаемой памяти.

4.  - [x] Реализуйте конструктор копирования и оператор присваивания для этого класса, добавьте в них распечатки с дампами. Пока не очень важно, как они реализованы, нам надо проследить их неявные вызовы. Сделайте тестовую программу, которая покажет, как объект Массив создается, как передается в функцию по значению (с помощью копирования), как вызывается деструктор копии, как один объект массива присваивается другому с помощью оператора присваивания, как вызываются деструкторы всех объектов в конце программы. Далее запретите создание конструктора копирования и оператора присваивания компилятором и убедитесь, что все их неявные вызовы стали синтаксическими ошибками.

5.  - [x] Добавьте в класс Массив оператор индексации. Реализуйте вариант класса Массив со внутренним хранением данных (аналог std::array). Реализуйте юнит-тесты для обоих вариантов класса Массив.

6.  - [x] Дополните классы Массив согласно их описанию на http://cppreference.com: http://en.cppreference.com/w/cpp/container/array и http://en.cppreference.com/w/cpp/container/vector.

6.  - [ ] Сделайте рефакторинг класса Стек с использованием собственного класса Массив. Проверьте, как работают старые юнит-тесты.

7. - [x] Реализуйте класс, ведущий себя в точности, как целое или дробное число. Проверьте его на каком-нибудь несложном алгоритме. Реализуйте класс "глючное число" (например, некоторые сложения вычитают и т.п.) и/или "демо-версия числа" (разрешается только два действия каждого вида с каждой переменной, если, например, к-во присваиваний или сложений оказывается больше двух, выводит надпись с предложением купить полную версию целого числа за $10).

8. - [ ] Реализуйте класс, ведущий себя как число, но не хранящий при этом никаких данных :) (подсказка: http://sizeof.livejournal.com/35378.html).

# Задание 3
1. - [x] Реализуйте конструктор копирования с глубоким копированием и оператор присваивания методами copy and swap и с использованием деструктора + размещающего синтаксиса new. Везде понаставьте распечатки имен функций, адресов и содержимого объектов!

2. - [x] Придумайте как можно менее тривиальные примеры, где класс Вектор неявно копируется.

3. - [x] Реализуйте итератор(ы) для классов Массив и Вектор.

4. - [x] Реализуйте перегрузку размещающего оператора new, обнуляющего содержимое выделенного массива.

5. - [x] Прочитайте про основы использования шаблонных классов и реализуйте простые шаблонные классы Массив и Вектор.

6. - [x] С помощью частичной специализации реализуйте эффективную реализацию array < bool > и vector < bool >.

7. - [x]  Стратегии. Подумайте, как можно обобщить сходные операции в классах array и vector.

# Задание 4
1. - [x] Реализовать типобезопасный printf с помощью variadic templates.

# Задание 5
1. - [x] auto_ptr.
2. - [ ] shared_ptr.
3. - [x] unique_ptr.
4. - [x] Пример падения программы при использовании auto_ptr.
5. - [x] Реализовать класс Exceptions.
6. - [x] Демонстрация использования класса Exceptions в main.
