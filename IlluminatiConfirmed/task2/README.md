Tasks:
1. Реализуйте класс Массив с внешним хранением данных (аналог std::vector). Конструктор копирования и оператор присваивания пока не определяйте. Во все методы добавьте распечатки названия функций и дампы, чтобы видеть, какие методы и когда вызывались, и в каком состоянии был объект. Дополните класс Массив деструктором и конструктором с единственным параметром (explicit пока не ставьте).

2. Сделайте тестовую программу для демонстрации неявного вызова конструктора с единственным параметром. Добавьте к его описанию explicit и убедитесь, что неявные вызовы стали синтаксическими ошибками.

3. Добавьте к тестовой программе функцию, принимающую объект класса Массив по значению (с копированием), и совершающую с ним какие-то операции. Конструктор копирования и оператор присваивания пока не определяйте. С помощью распечаток и дампов пронаблюдайте вызов двух деструкторов для двух разных объектов класса Массив (оригинала и копии; они должны различаться по значению this) и несоответствие количества распечаток от конструкторов распечаткам от деструкторов, т.к. конструктор копирования Вы пока не определили, компилятор сгенерирует его сам и распечатки в нем, соответственно, не будет. Пронаблюдайте двойное освобождение памяти, в которой хранятся данные массива, для этого можно написать свою функцию для удаления массива, снабдив ее распечаткой с указанием адреса освобождаемой памяти.

4. Реализуйте конструктор копирования и оператор присваивания для этого класса, добавьте в них распечатки с дампами. Пока не очень важно, как они реализованы, нам надо проследить их неявные вызовы. Сделайте тестовую программу, которая покажет, как объект Массив создается, как передается в функцию по значению (с помощью копирования), как вызывается деструктор копии, как один объект массива присваивается другому с помощью оператора присваивания, как вызываются деструкторы всех объектов в конце программы. Далее запретите создание конструктора копирования и оператора присваивания компилятором и убедитесь, что все их неявные вызовы стали синтаксическими ошибками.

5. Добавьте в класс Массив оператор индексации. Реализуйте вариант класса Массив со внутренним хранением данных (аналог std::array). Реализуйте юнит-тесты для обоих вариантов класса Массив.

6. Дополните классы Массив согласно их описанию на http://cppreference.com: http://en.cppreference.com/w/cpp/container/array и http://en.cppreference.com/w/cpp/container/vector.

6. Сделайте рефакторинг класса Стек с использованием собственного класса Массив. Проверьте, как работают старые юнит-тесты.

7. Реализуйте класс, ведущий себя в точности, как целое или дробное число. Проверьте его на каком-нибудь несложном алгоритме. Реализуйте класс "глючное число" (например, некоторые сложения вычитают и т.п.) и/или "демо-версия числа" (разрешается только два действия каждого вида с каждой переменной, если, например, к-во присваиваний или сложений оказывается больше двух, выводит надпись с предложением купить полную версию целого числа за $10).

8. Реализуйте класс, ведущий себя как число, но не хранящий при этом никаких данных :) (подсказка: http://sizeof.livejournal.com/35378.html).

9. Все, конечно, положите на Гитхаб! Для каждой задачи делайте отдельную ветку.
